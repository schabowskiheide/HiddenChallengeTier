<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Hidden Challenge Tier ‚Äî Zama FHEVM</title>
  <style>
  :root {
    --bg-body: #020617;
    --bg-panel: #020617;
    --bg-card: #020617;
    --accent: #f97316;
    --accent-soft: rgba(249, 115, 22, 0.14);
    --accent-strong: #fb923c;
    --text-main: #e5e7eb;
    --text-muted: #9ca3af;
    --border-strong: #e5e7eb;
    --border-soft: rgba(148, 163, 184, 0.6);
    --radius-lg: 14px;
    --radius-pill: 999px;
  }

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    background:
      radial-gradient(circle at top, rgba(249, 115, 22, 0.18), transparent 55%),
      radial-gradient(circle at bottom, rgba(15, 23, 42, 0.9), #020617 70%);
    color: var(--text-main);
    padding: 30px 18px;
  }

  body::before {
    content: "";
    position: fixed;
    inset: 0;
    background-image:
      linear-gradient(to right, rgba(148, 163, 184, 0.12) 1px, transparent 1px),
      linear-gradient(to bottom, rgba(148, 163, 184, 0.08) 1px, transparent 1px);
    background-size: 72px 72px;
    mix-blend-mode: soft-light;
    opacity: 0.5;
    pointer-events: none;
  }

  .container {
    position: relative;
    z-index: 1;
    max-width: 980px;
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    gap: 22px;
  }

  header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 14px;
    flex-wrap: wrap;
    padding: 14px 18px;
    border-radius: 0;
    background: transparent;
    border-bottom: 2px solid var(--border-strong);
    box-shadow: none;
    position: relative;
  }

  header::after {
    content: "";
    position: absolute;
    left: 0;
    bottom: -2px;
    width: 40%;
    height: 2px;
    background: linear-gradient(90deg, var(--accent), transparent);
  }

  h1 {
    margin: 0;
    font-size: 1.4rem;
    letter-spacing: 0.16em;
    text-transform: uppercase;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  h1 span {
    padding: 2px 8px;
    border-radius: 0;
    border: 2px solid var(--border-strong);
    font-size: 0.7rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
  }

  h2 {
    margin: 0 0 4px 0;
    font-size: 0.95rem;
    letter-spacing: 0.14em;
    text-transform: uppercase;
  }

  h2::before {
    content: "#";
    margin-right: 8px;
    color: var(--accent-strong);
  }

  .card {
    border-radius: 0;
    padding: 16px 18px 14px;
    background: var(--bg-card);
    border: 2px solid var(--border-strong);
    position: relative;
    overflow: hidden;
  }

  .card::before {
    content: "";
    position: absolute;
    inset: 0;
    background: repeating-linear-gradient(
      -45deg,
      rgba(15, 23, 42, 0.4),
      rgba(15, 23, 42, 0.4) 1px,
      transparent 1px,
      transparent 4px
    );
    opacity: 0.35;
    pointer-events: none;
  }

  .card::after {
    content: "FHE CHALLENGE";
    position: absolute;
    top: 10px;
    right: -12px;
    font-size: 0.6rem;
    letter-spacing: 0.25em;
    text-transform: uppercase;
    color: rgba(148, 163, 184, 0.45);
    transform: rotate(90deg);
    transform-origin: top right;
    pointer-events: none;
  }

  .card > * {
    position: relative;
    z-index: 1;
  }

  p[style] {
    color: var(--text-muted) !important;
    font-size: 0.8rem !important;
    max-width: 560px;
  }

  .row {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 10px;
  }

  .col {
    flex: 1;
    min-width: 190px;
  }

  label {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    font-size: 0.75rem;
    margin-top: 6px;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    color: var(--text-muted);
  }

  label::before {
    content: "‚ñ¢";
    font-size: 0.7rem;
    color: var(--accent-strong);
  }

  input {
    width: 100%;
    margin-top: 4px;
    padding: 9px 10px;
    border-radius: 0;
    border: 2px solid var(--border-strong);
    background: #020617;
    color: var(--text-main);
    font-size: 0.9rem;
    outline: none;
    transition: border-color 0.16s ease, background 0.16s ease, transform 0.06s ease;
  }

  input::placeholder {
    color: #4b5563;
  }

  input:focus {
    border-color: var(--accent-strong);
    background: #020617;
    transform: translateY(-1px);
  }

  button {
    border: 2px solid var(--border-strong);
    border-radius: 0;
    padding: 8px 16px;
    cursor: pointer;
    background: #020617;
    color: var(--text-main);
    font-weight: 700;
    font-size: 0.86rem;
    letter-spacing: 0.16em;
    text-transform: uppercase;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    box-shadow: 4px 4px 0 #0b1120;
    transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.12s ease, color 0.12s ease;
    white-space: nowrap;
  }

  button::before {
    content: "‚ñ∂";
    font-size: 0.8rem;
  }

  button.secondary {
    background: #0b1120;
  }

  button.success {
    background: var(--accent);
    color: #111827;
    border-color: #fbbf24;
  }

  button.success::before {
    content: "‚úì";
  }

  button:disabled {
    opacity: 0.55;
    cursor: not-allowed;
    box-shadow: 2px 2px 0 #020617;
  }

  button:not(:disabled):hover {
    transform: translate(-2px, -2px);
    box-shadow: 6px 6px 0 #0b1120;
    background: var(--accent-soft);
    color: var(--accent-strong);
  }

  .status {
    margin-top: 8px;
    padding: 6px 10px;
    border-radius: 0;
    font-size: 0.78rem;
    display: none;
    border: 2px solid var(--border-strong);
    background: #020617;
    color: var(--text-muted);
    letter-spacing: 0.12em;
    text-transform: uppercase;
    display: none;
  }

  .status::before {
    content: "‚óè";
    margin-right: 6px;
    font-size: 0.6rem;
  }

  .status.pending {
    display: inline-block;
    border-color: #facc15;
    color: #facc15;
  }

  .status.pending::before {
    animation: blink 0.9s infinite alternate;
  }

  .status.success {
    display: inline-block;
    border-color: #4ade80;
    color: #4ade80;
  }

  .status.success::before {
    content: "‚úî";
  }

  .status.error {
    display: inline-block;
    border-color: #f97373;
    color: #f97373;
  }

  .status.error::before {
    content: "√ó";
  }

  pre {
    background: #020617;
    border-radius: 0;
    border: 2px solid var(--border-strong);
    padding: 8px 10px;
    font-size: 0.78rem;
    overflow: auto;
    max-height: 220px;
    white-space: pre-wrap;
    color: #e5e7eb;
    margin-top: 8px;
  }

  .result-box {
    margin-top: 10px;
    padding: 10px 12px;
    border-radius: 0;
    font-size: 0.9rem;
    display: none;
    border: 2px solid var(--border-strong);
  }

  .result-box.none {
    background: #020617;
    color: var(--text-muted);
  }

  .result-box.rookie {
    background: #111827;
    color: #bfdbfe;
    border-color: #60a5fa;
  }

  .result-box.pro {
    background: #022c22;
    color: #bbf7d0;
    border-color: #22c55e;
  }

  .result-box.legend {
    background: #451a03;
    color: #fed7aa;
    border-color: #fb923c;
  }

  footer {
    margin-top: 20px;
    font-size: 0.8rem;
    color: var(--text-muted);
    text-align: left;
    border-top: 2px solid var(--border-strong);
    padding-top: 8px;
    letter-spacing: 0.16em;
    text-transform: uppercase;
  }

  #btnConnect {
    background: #facc15;
    color: #111827;
    border-color: #e5e7eb;
  }

  #btnConnect::before {
    content: "‚óé";
  }

  #btnConnect:hover:not(:disabled) {
    background: #fde68a;
    color: #111827;
  }

  @keyframes blink {
    from { opacity: 0.4; }
    to { opacity: 1; }
  }

  @media (max-width: 640px) {
    body {
      padding: 22px 14px;
    }

    header {
      padding: 12px 10px;
      border-bottom-width: 2px;
    }

    .card {
      padding: 14px 12px 12px;
    }

    h1 {
      font-size: 1.2rem;
    }
  }
</style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üßó Hidden Challenge Tier <span>Console Mode</span></h1>

      <button id="btnConnect">Connect Wallet</button>
    </header>

    <!-- 1. SUBMIT COMPLETED CHALLENGES -->
    <section class="card">
      <h2>1. Submit Completed Challenges</h2>
      <p style="font-size:0.85rem;color:#9ca3af;">
        Encrypt the number of completed challenges and bind it to a player key. The contract keeps only an encrypted value.
      </p>

      <div class="row">
        <div class="col">
          <label>Player Key (e.g. "player-1")</label>
          <input id="playerKey" type="text" placeholder="player-1" value="player-1" />
        </div>
        <div class="col">
          <label>Completed Challenges (0‚Äì65535)</label>
          <input id="completedCount" type="number" min="0" max="65535" value="7" />
        </div>
      </div>

      <div class="row" style="margin-top:12px;">
        <button id="btnSubmitCompleted" class="success">Submit Encrypted Progress</button>
      </div>
      <div id="submitStatus" class="status"></div>
      <pre id="submitLog" style="display:none;"></pre>
    </section>

    <!-- 2. COMPUTE TIER -->
    <section class="card">
      <h2>2. Compute Hidden Tier</h2>
      <p style="font-size:0.85rem;color:#9ca3af;">
        The contract compares your encrypted count against Rookie / Pro / Legend thresholds and stores an encrypted tier code.
      </p>

      <div class="row">
        <div class="col">
          <label>Player Key (must match)</label>
          <input id="tierPlayerKey" type="text" placeholder="player-1" value="player-1" />
        </div>
      </div>

      <div class="row" style="margin-top:12px;">
        <button id="btnComputeTier" class="success">Compute Encrypted Tier</button>
      </div>
      <div id="tierStatus" class="status"></div>
      <pre id="tierHandleOutput" style="display:none;"></pre>
    </section>

    <!-- 3. MAKE PUBLIC & DECRYPT -->
    <section class="card">
      <h2>3. Reveal Tier (Public Decrypt)</h2>
      <p style="font-size:0.85rem;color:#9ca3af;">
        Make your encrypted tier publicly decryptable and reveal only the level name, never the raw challenge count.
      </p>

      <div class="row">
        <div class="col">
          <label>Player Key</label>
          <input id="decryptPlayerKey" type="text" placeholder="player-1" value="player-1" />
        </div>
      </div>

      <div class="row" style="margin-top:12px;">
        <button id="btnGetTierHandle" class="secondary">Get Tier Handle</button>
        <button id="btnMakeTierPublic">Make Tier Public</button>
        <button id="btnDecryptTier" class="success">Decrypt Tier</button>
      </div>

      <div id="decryptStatus" class="status"></div>
      <pre id="handleOutput" style="display:none;"></pre>
      <div id="tierResult" class="result-box"></div>
    </section>

    <footer>
      Zama FHEVM ¬∑ Hidden Challenge Tier ¬∑ Relayer SDK 0.3.0 ¬∑ Ethers v6
    </footer>
  </div>

  <script type="module">
        import { initSDK, createInstance, SepoliaConfig } from "https://cdn.zama.org/relayer-sdk-js/0.3.0-5/relayer-sdk-js.js";
    import { BrowserProvider, Contract, getAddress, keccak256, toUtf8Bytes } from "https://cdn.jsdelivr.net/npm/ethers@6.15.0/+esm";

    const CONFIG = {
      RELAYER_URL: "https://relayer.testnet.zama.org",
      GATEWAY_URL: "https://gateway.testnet.zama.org",
      CONTRACT_ADDRESS: "0x3b2b61469d8a633d895f7F3b0e8ed94e1F30f187"
    };

    const ABI = [
      "function submitCompleted(bytes32 userId, bytes32 encCompleted, bytes attestation) external",
      "function computeTier(bytes32 userId, bytes32 encZero, bytes attestation) external returns (bytes32)",
      "function makeTierPublic(bytes32 userId) external",
      "function tierHandle(bytes32 userId) external view returns (bytes32)",
      "function entryExists(bytes32 userId) external view returns (bool)",
      "function tierExists(bytes32 userId) external view returns (bool)",
      "function entryOwner(bytes32 userId) external view returns (address)"
    ];

    let provider, signer, address, contract, relayer;
    const $ = s => document.querySelector(s);

    const log = (title, data) => console.log(`%c[${title}]`, "color:#38bdf8;font-weight:bold;", data);
    const logError = (title, err) => console.error(`%c[ERROR:${title}]`, "color:#ef4444;font-weight:bold;", err);

    const toHex = u8 => "0x" + Array.from(u8, b => b.toString(16).padStart(2,"0")).join("");

    const setStatus = (id, msg, type="pending") => {
      const el = $(id);
      if (!el) return;
      el.textContent = msg;
      el.className = `status ${type}`;
      el.style.display = "block";
      log(`STATUS ${id}`, msg);
    };
    const clearStatus = id => {
      const el = $(id);
      if (el) el.style.display = "none";
    };

    const toUserId = (text) => {
      const t = (text || "").trim();
      const h = keccak256(toUtf8Bytes(t));
      log("UserId derived", { key: t, userId: h });
      return h;
    };

    async function connect() {
      try {
        log("Connect", "start");
        if (!window.ethereum) throw new Error("MetaMask not installed");

        provider = provider || new BrowserProvider(window.ethereum);
        const accounts = await provider.send("eth_requestAccounts", []);
        log("Accounts", accounts);

        signer = signer || await provider.getSigner();
        address = address || await signer.getAddress();
        log("Address", address);

        contract = contract || new Contract(getAddress(CONFIG.CONTRACT_ADDRESS), ABI, signer);
        log("Contract", CONFIG.CONTRACT_ADDRESS);

        $("#btnConnect").textContent = address.slice(0, 6) + "‚Ä¶" + address.slice(-4);

        if (!relayer) {
          await initSDK();
          relayer = await createInstance({
            ...SepoliaConfig,
            relayerUrl: CONFIG.RELAYER_URL,
            gatewayUrl: CONFIG.GATEWAY_URL,
            network: window.ethereum,
            debug: true
          });
          log("Relayer", "instance created");
        }

        log("Connect", "done");
        return true;
      } catch (e) {
        logError("Connect", e);
        setStatus("#submitStatus", "Wallet/relayer connection failed", "error");
        return false;
      }
    }

    $("#btnConnect").onclick = connect;

    async function encryptEuint16(value) {
      if (!relayer) throw new Error("Relayer not initialized");
      if (!address) throw new Error("No wallet address");

      log("EncryptEuint16", { value });

      const enc = relayer.createEncryptedInput(
        getAddress(CONFIG.CONTRACT_ADDRESS),
        getAddress(address)
      );

      enc.add16(BigInt(value));

      const { handles, inputProof } = await enc.encrypt();
      log("Encrypt result", { handleCount: handles.length, type0: typeof handles[0] });

      const hRaw = handles[0]?.handle || handles[0]?.ciphertext || handles[0];
      const handle = typeof hRaw === "string" ? hRaw : toHex(hRaw);

      const att = typeof inputProof === "string"
        ? (inputProof.startsWith("0x") ? inputProof : "0x" + inputProof)
        : toHex(inputProof);

      log("EncryptEuint16 final", { handle, attLen: att.length });
      return { handle, attestation: att };
    }

    // 1) SUBMIT COMPLETED
    $("#btnSubmitCompleted").onclick = async () => {
      try {
        log("SubmitCompleted", "click");
        if (!(await connect())) return;

        clearStatus("#submitStatus");
        $("#submitLog").style.display = "none";

        const playerKey = $("#playerKey").value;
        const completed = parseInt($("#completedCount").value, 10) || 0;
        const userId = toUserId(playerKey);

        setStatus("#submitStatus", "Encrypting completed challenges‚Ä¶", "pending");
        const { handle, attestation } = await encryptEuint16(completed);

        log("submitCompleted args", { userId, handle, attLen: attestation.length });

        setStatus("#submitStatus", "Submitting submitCompleted tx‚Ä¶", "pending");
        const tx = await contract.submitCompleted(userId, handle, attestation);
        log("Tx submitCompleted sent", tx.hash);
        const receipt = await tx.wait();
        log("Tx submitCompleted receipt", { blockNumber: receipt.blockNumber, status: receipt.status });

        $("#submitLog").textContent =
          `Progress submitted
playerKey: ${playerKey}
userId: ${userId}
completed: ${completed}
encHandle: ${handle}`;
        $("#submitLog").style.display = "block";

        setStatus("#submitStatus", "Encrypted progress submitted", "success");
      } catch (e) {
        logError("SubmitCompleted", e);
        setStatus("#submitStatus", "Error: " + (e.message || String(e)), "error");
      }
    };

    // 2) COMPUTE TIER
    $("#btnComputeTier").onclick = async () => {
      try {
        log("ComputeTier", "click");
        if (!(await connect())) return;

        clearStatus("#tierStatus");
        $("#tierHandleOutput").style.display = "none";

        const playerKey = $("#tierPlayerKey").value;
        const userId = toUserId(playerKey);
        const zeroVal = 0;

        setStatus("#tierStatus", "Encrypting zero value‚Ä¶", "pending");
        const { handle: encZero, attestation } = await encryptEuint16(zeroVal);

        log("computeTier args", { userId, encZero, attLen: attestation.length });

        setStatus("#tierStatus", "Submitting computeTier tx‚Ä¶", "pending");
        const tx = await contract.computeTier(userId, encZero, attestation);
        log("Tx computeTier sent", tx.hash);
        const receipt = await tx.wait();
        log("Tx computeTier receipt", { blockNumber: receipt.blockNumber, status: receipt.status });

        setStatus("#tierStatus", "Tier computed, fetching handle‚Ä¶", "pending");
        const handle = await contract.tierHandle(userId);
        log("tierHandle()", handle);

        $("#tierHandleOutput").textContent = "Tier Handle:\n" + handle;
        $("#tierHandleOutput").style.display = "block";

        $("#decryptPlayerKey").value = playerKey;
        $("#handleOutput").textContent = "Tier Handle:\n" + handle;
        $("#handleOutput").style.display = "block";

        setStatus("#tierStatus", "Tier handle stored", "success");
      } catch (e) {
        logError("ComputeTier", e);
        setStatus("#tierStatus", "Error: " + (e.message || String(e)), "error");
      }
    };

    // 3) MAKE PUBLIC & GET HANDLE
    $("#btnMakeTierPublic").onclick = async () => {
      try {
        log("MakeTierPublic", "click");
        if (!(await connect())) return;

        clearStatus("#decryptStatus");

        const playerKey = $("#decryptPlayerKey").value;
        const userId = toUserId(playerKey);

        setStatus("#decryptStatus", "Submitting makeTierPublic tx‚Ä¶", "pending");
        const tx = await contract.makeTierPublic(userId);
        log("Tx makeTierPublic sent", tx.hash);
        const receipt = await tx.wait();
        log("Tx makeTierPublic receipt", { blockNumber: receipt.blockNumber, status: receipt.status });

        setStatus("#decryptStatus", "Tier is now public", "success");
      } catch (e) {
        logError("MakeTierPublic", e);
        setStatus("#decryptStatus", "Error: " + (e.message || String(e)), "error");
      }
    };

    $("#btnGetTierHandle").onclick = async () => {
      try {
        log("GetTierHandle", "click");
        if (!(await connect())) return;

        clearStatus("#decryptStatus");
        $("#handleOutput").style.display = "none";

        const playerKey = $("#decryptPlayerKey").value;
        const userId = toUserId(playerKey);

        setStatus("#decryptStatus", "Fetching tier handle‚Ä¶", "pending");
        const handle = await contract.tierHandle(userId);
        log("tierHandle()", handle);

        $("#handleOutput").textContent = "Tier Handle:\n" + handle;
        $("#handleOutput").style.display = "block";

        setStatus("#decryptStatus", "Handle retrieved", "success");
      } catch (e) {
        logError("GetTierHandle", e);
        setStatus("#decryptStatus", "Error: " + (e.message || String(e)), "error");
      }
    };

    // DECRYPT TIER
    function cleanHandle(raw) {
      return String(raw).trim().split("\n").pop().trim();
    }

    async function decryptTier(handleHex) {
      if (!relayer) throw new Error("Relayer not initialized");

      const handle = String(handleHex).trim();
      if (!handle.startsWith("0x") || handle.length !== 66)
        throw new Error("Invalid ciphertext handle");

      const request = [handle];
      const out = await relayer.publicDecrypt(request);

      if (!out || typeof out !== "object" || !out.clearValues)
        throw new Error("Invalid decrypt response");

      const lower = handle.toLowerCase();
      const result = out.clearValues[handle] ?? out.clearValues[lower];

      if (result === undefined || result === null)
        throw new Error("Decrypt produced no value");

      return Number(result); // 0..3
    }

    $("#btnDecryptTier").onclick = async () => {
      try {
        await connect();
        clearStatus("#decryptStatus");

        const raw = $("#handleOutput").textContent || $("#tierHandleOutput").textContent;
        const handle = cleanHandle(raw);

        const code = await decryptTier(handle);

        const resultDiv = $("#tierResult");
        resultDiv.style.display = "block";

        if (code === 0) {
          resultDiv.className = "result-box none";
          resultDiv.textContent = "Tier: None (0). Keep climbing!";
        } else if (code === 1) {
          resultDiv.className = "result-box rookie";
          resultDiv.textContent = "Tier: Rookie (1). You‚Äôve started your journey.";
        } else if (code === 2) {
          resultDiv.className = "result-box pro";
          resultDiv.textContent = "Tier: Pro (2). Strong challenger!";
        } else if (code === 3) {
          resultDiv.className = "result-box legend";
          resultDiv.textContent = "Tier: Legend (3). Top of the mountain!";
        } else {
          resultDiv.className = "result-box none";
          resultDiv.textContent = "Unexpected tier code: " + code;
        }

        setStatus("#decryptStatus", "‚úÖ Tier decrypted", "success");
      } catch (e) {
        logError("DecryptTier", e);
        setStatus("#decryptStatus", "Error: " + (e.message || String(e)), "error");
      }
    };

    log("Script", "‚úÖ Hidden Challenge handlers attached and ready");
  </script>
</body>
</html>
